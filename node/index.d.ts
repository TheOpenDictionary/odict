/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Dictionary {
  constructor(data: Buffer, options?: DictionaryOptions | undefined | null);
  lookup(
    query: string | Array<string>,
    options?: LookupOptions | undefined | null,
  ): Array<LookupResult>;
  lexicon(): Array<string>;
  index(options?: IndexOptions | undefined | null): void;
  search(
    query: string,
    options?: SearchOptions | undefined | null,
  ): Array<Entry>;
  tokenize(
    text: string,
    options?: TokenizeOptions | undefined | null,
  ): Array<Token>;
}

export declare function compile(xml: string): Buffer;

export interface Definition {
  id?: string;
  value: string;
  examples: Array<Example>;
  notes: Array<Note>;
}

export interface DictionaryOptions {
  split?: SplitOptions;
  index?: IndexOptions;
  search?: SearchOptions;
}

export interface Entry {
  term: string;
  seeAlso?: string;
  etymologies: Array<Etymology>;
  forms: Array<Form>;
}

export interface Etymology {
  id?: string;
  pronunciation?: string;
  description?: string;
  senses: Record<string, Sense>;
}

export interface Example {
  value: string;
}

export interface Form {
  term: string;
  kind?: FormKind;
}

export declare const enum FormKind {
  Conjugation = 0,
  Inflection = 1,
  Plural = 2,
  Singular = 3,
  Comparative = 4,
  Superlative = 5,
  Other = 6,
}

export interface Group {
  id?: string;
  description: string;
  definitions: Array<Definition>;
}

export interface IndexOptions {
  directory?: string;
  memory?: number;
  overwrite?: boolean;
}

export interface LookupOptions {
  split?: number;
  follow?: boolean;
  insensitive?: boolean;
}

export interface LookupResult {
  entry: Entry;
  directedFrom?: Entry;
}

export interface Note {
  id?: string;
  value: string;
  examples: Array<Example>;
}

export interface SearchOptions {
  directory?: string;
  threshold?: number;
  autoindex?: boolean;
  limit?: number;
}

export interface Sense {
  pos: string;
  lemma?: string;
  definitions: Array<Definition | Group>;
}

export interface SplitOptions {
  minLength?: number;
}

export interface Token {
  lemma: string;
  language?: string;
  entries: Array<LookupResult>;
  kind: string;
  script: string;
  start: number;
  end: number;
}

export interface TokenizeOptions {
  follow?: boolean;
  allowList?: Array<string>;
  insensitive?: boolean;
}
