// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package types

import (
	"bytes"

	flatbuffers "github.com/google/flatbuffers/go"
)

type NoteBuffer struct {
	_tab flatbuffers.Table
}

func GetRootAsNoteBuffer(buf []byte, offset flatbuffers.UOffsetT) *NoteBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &NoteBuffer{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsNoteBuffer(buf []byte, offset flatbuffers.UOffsetT) *NoteBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &NoteBuffer{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *NoteBuffer) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *NoteBuffer) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *NoteBuffer) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *NoteBuffer) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *NoteBuffer) Examples(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *NoteBuffer) ExamplesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func NoteBufferStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func NoteBufferAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func NoteBufferAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(value), 0)
}
func NoteBufferAddExamples(builder *flatbuffers.Builder, examples flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(examples), 0)
}
func NoteBufferStartExamplesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NoteBufferEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type DefinitionBuffer struct {
	_tab flatbuffers.Table
}

func GetRootAsDefinitionBuffer(buf []byte, offset flatbuffers.UOffsetT) *DefinitionBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DefinitionBuffer{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsDefinitionBuffer(buf []byte, offset flatbuffers.UOffsetT) *DefinitionBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &DefinitionBuffer{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *DefinitionBuffer) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DefinitionBuffer) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *DefinitionBuffer) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *DefinitionBuffer) Value() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *DefinitionBuffer) Examples(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *DefinitionBuffer) ExamplesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *DefinitionBuffer) Notes(obj *NoteBuffer, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *DefinitionBuffer) NotesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func DefinitionBufferStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func DefinitionBufferAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func DefinitionBufferAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(value), 0)
}
func DefinitionBufferAddExamples(builder *flatbuffers.Builder, examples flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(examples), 0)
}
func DefinitionBufferStartExamplesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func DefinitionBufferAddNotes(builder *flatbuffers.Builder, notes flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(notes), 0)
}
func DefinitionBufferStartNotesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func DefinitionBufferEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type EtymologyBuffer struct {
	_tab flatbuffers.Table
}

func GetRootAsEtymologyBuffer(buf []byte, offset flatbuffers.UOffsetT) *EtymologyBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &EtymologyBuffer{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsEtymologyBuffer(buf []byte, offset flatbuffers.UOffsetT) *EtymologyBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &EtymologyBuffer{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *EtymologyBuffer) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *EtymologyBuffer) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *EtymologyBuffer) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *EtymologyBuffer) Pronunciation() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *EtymologyBuffer) Description() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *EtymologyBuffer) Senses(obj *SenseBuffer, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *EtymologyBuffer) SensesByKey(obj *SenseBuffer, key POS) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		return obj.LookupByKey(key, x, rcv._tab.Bytes)
	}
	return false
}

func (rcv *EtymologyBuffer) SensesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func EtymologyBufferStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func EtymologyBufferAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func EtymologyBufferAddPronunciation(builder *flatbuffers.Builder, pronunciation flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(pronunciation), 0)
}
func EtymologyBufferAddDescription(builder *flatbuffers.Builder, description flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(description), 0)
}
func EtymologyBufferAddSenses(builder *flatbuffers.Builder, senses flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(senses), 0)
}
func EtymologyBufferStartSensesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func EtymologyBufferEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type GroupBuffer struct {
	_tab flatbuffers.Table
}

func GetRootAsGroupBuffer(buf []byte, offset flatbuffers.UOffsetT) *GroupBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &GroupBuffer{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsGroupBuffer(buf []byte, offset flatbuffers.UOffsetT) *GroupBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &GroupBuffer{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *GroupBuffer) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *GroupBuffer) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *GroupBuffer) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GroupBuffer) Description() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GroupBuffer) Definitions(obj *DefinitionBuffer, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *GroupBuffer) DefinitionsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func GroupBufferStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func GroupBufferAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func GroupBufferAddDescription(builder *flatbuffers.Builder, description flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(description), 0)
}
func GroupBufferAddDefinitions(builder *flatbuffers.Builder, definitions flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(definitions), 0)
}
func GroupBufferStartDefinitionsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GroupBufferEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type SenseBuffer struct {
	_tab flatbuffers.Table
}

func GetRootAsSenseBuffer(buf []byte, offset flatbuffers.UOffsetT) *SenseBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SenseBuffer{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSenseBuffer(buf []byte, offset flatbuffers.UOffsetT) *SenseBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SenseBuffer{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SenseBuffer) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SenseBuffer) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SenseBuffer) Pos() POS {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return POS(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *SenseBuffer) MutatePos(n POS) bool {
	return rcv._tab.MutateInt8Slot(4, int8(n))
}

func SenseBufferKeyCompare(o1, o2 flatbuffers.UOffsetT, buf []byte) bool {
	obj1 := &SenseBuffer{}
	obj2 := &SenseBuffer{}
	obj1.Init(buf, flatbuffers.UOffsetT(len(buf))-o1)
	obj2.Init(buf, flatbuffers.UOffsetT(len(buf))-o2)
	return obj1.Pos() < obj2.Pos()
}

func (rcv *SenseBuffer) LookupByKey(key POS, vectorLocation flatbuffers.UOffsetT, buf []byte) bool {
	span := flatbuffers.GetUOffsetT(buf[vectorLocation-4:])
	start := flatbuffers.UOffsetT(0)
	for span != 0 {
		middle := span / 2
		tableOffset := flatbuffers.GetIndirectOffset(buf, vectorLocation+4*(start+middle))
		obj := &SenseBuffer{}
		obj.Init(buf, tableOffset)
		val := obj.Pos()
		comp := 0
		if val > key {
			comp = 1
		} else if val < key {
			comp = -1
		}
		if comp > 0 {
			span = middle
		} else if comp < 0 {
			middle += 1
			start += middle
			span -= middle
		} else {
			rcv.Init(buf, tableOffset)
			return true
		}
	}
	return false
}

func (rcv *SenseBuffer) Definitions(obj *DefinitionBuffer, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SenseBuffer) DefinitionsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SenseBuffer) Groups(obj *GroupBuffer, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SenseBuffer) GroupsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func SenseBufferStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func SenseBufferAddPos(builder *flatbuffers.Builder, pos POS) {
	builder.PrependInt8Slot(0, int8(pos), 0)
}
func SenseBufferAddDefinitions(builder *flatbuffers.Builder, definitions flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(definitions), 0)
}
func SenseBufferStartDefinitionsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SenseBufferAddGroups(builder *flatbuffers.Builder, groups flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(groups), 0)
}
func SenseBufferStartGroupsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SenseBufferEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type EntryBuffer struct {
	_tab flatbuffers.Table
}

func GetRootAsEntryBuffer(buf []byte, offset flatbuffers.UOffsetT) *EntryBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &EntryBuffer{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsEntryBuffer(buf []byte, offset flatbuffers.UOffsetT) *EntryBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &EntryBuffer{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *EntryBuffer) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *EntryBuffer) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *EntryBuffer) Key() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func EntryBufferKeyCompare(o1, o2 flatbuffers.UOffsetT, buf []byte) bool {
	obj1 := &EntryBuffer{}
	obj2 := &EntryBuffer{}
	obj1.Init(buf, flatbuffers.UOffsetT(len(buf))-o1)
	obj2.Init(buf, flatbuffers.UOffsetT(len(buf))-o2)
	return string(obj1.Key()) < string(obj2.Key())
}

func (rcv *EntryBuffer) LookupByKey(key string, vectorLocation flatbuffers.UOffsetT, buf []byte) bool {
	span := flatbuffers.GetUOffsetT(buf[vectorLocation-4:])
	start := flatbuffers.UOffsetT(0)
	bKey := []byte(key)
	for span != 0 {
		middle := span / 2
		tableOffset := flatbuffers.GetIndirectOffset(buf, vectorLocation+4*(start+middle))
		obj := &EntryBuffer{}
		obj.Init(buf, tableOffset)
		comp := bytes.Compare(obj.Key(), bKey)
		if comp > 0 {
			span = middle
		} else if comp < 0 {
			middle += 1
			start += middle
			span -= middle
		} else {
			rcv.Init(buf, tableOffset)
			return true
		}
	}
	return false
}

func (rcv *EntryBuffer) Term() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *EntryBuffer) See() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *EntryBuffer) Etymologies(obj *EtymologyBuffer, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *EntryBuffer) EtymologiesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func EntryBufferStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func EntryBufferAddKey(builder *flatbuffers.Builder, key flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(key), 0)
}
func EntryBufferAddTerm(builder *flatbuffers.Builder, term flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(term), 0)
}
func EntryBufferAddSee(builder *flatbuffers.Builder, see flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(see), 0)
}
func EntryBufferAddEtymologies(builder *flatbuffers.Builder, etymologies flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(etymologies), 0)
}
func EntryBufferStartEtymologiesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func EntryBufferEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type DictionaryBuffer struct {
	_tab flatbuffers.Table
}

func GetRootAsDictionaryBuffer(buf []byte, offset flatbuffers.UOffsetT) *DictionaryBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &DictionaryBuffer{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsDictionaryBuffer(buf []byte, offset flatbuffers.UOffsetT) *DictionaryBuffer {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &DictionaryBuffer{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *DictionaryBuffer) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *DictionaryBuffer) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *DictionaryBuffer) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *DictionaryBuffer) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *DictionaryBuffer) Entries(obj *EntryBuffer, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *DictionaryBuffer) EntriesByKey(obj *EntryBuffer, key string) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		return obj.LookupByKey(key, x, rcv._tab.Bytes)
	}
	return false
}

func (rcv *DictionaryBuffer) EntriesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func DictionaryBufferStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func DictionaryBufferAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func DictionaryBufferAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func DictionaryBufferAddEntries(builder *flatbuffers.Builder, entries flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(entries), 0)
}
func DictionaryBufferStartEntriesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func DictionaryBufferEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
