// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum schema_POS: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case v = 0
  case n = 1
  case adj = 2
  case pro = 3
  case adv = 4
  case prep = 5
  case conj = 6
  case intj = 7
  case pref = 8
  case suff = 9
  case part = 10
  case art = 11
  case un = 12

  public static var max: schema_POS { return .un }
  public static var min: schema_POS { return .v }
}


public struct schema_Etymology: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsEtymology(bb: ByteBuffer) -> schema_Etymology { return schema_Etymology(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case description = 6
    case usages = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var description: String? { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.description.v) }
  public var usagesCount: Int32 { let o = _accessor.offset(VTOFFSET.usages.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func usages(at index: Int32) -> schema_Usage? { let o = _accessor.offset(VTOFFSET.usages.v); return o == 0 ? nil : schema_Usage(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func usagesBy(key: schema_POS) -> schema_Usage? { let o = _accessor.offset(VTOFFSET.usages.v); return o == 0 ? nil : schema_Usage.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public static func startEtymology(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(description: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: description, at: VTOFFSET.description.p) }
  public static func addVectorOf(usages: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: usages, at: VTOFFSET.usages.p) }
  public static func endEtymology(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEtymology(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    descriptionOffset description: Offset = Offset(),
    usagesVectorOffset usages: Offset = Offset()
  ) -> Offset {
    let __start = schema_Etymology.startEtymology(&fbb)
    schema_Etymology.add(id: id, &fbb)
    schema_Etymology.add(description: description, &fbb)
    schema_Etymology.addVectorOf(usages: usages, &fbb)
    return schema_Etymology.endEtymology(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.usages.p, fieldName: "usages", required: false, type: ForwardOffset<Vector<ForwardOffset<schema_Usage>, schema_Usage>>.self)
    _v.finish()
  }
}

public struct schema_Group: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsGroup(bb: ByteBuffer) -> schema_Group { return schema_Group(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case description = 6
    case definitions = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var description: String? { let o = _accessor.offset(VTOFFSET.description.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.description.v) }
  public var definitionsCount: Int32 { let o = _accessor.offset(VTOFFSET.definitions.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func definitions(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.definitions.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startGroup(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(description: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: description, at: VTOFFSET.description.p) }
  public static func addVectorOf(definitions: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: definitions, at: VTOFFSET.definitions.p) }
  public static func endGroup(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGroup(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    descriptionOffset description: Offset = Offset(),
    definitionsVectorOffset definitions: Offset = Offset()
  ) -> Offset {
    let __start = schema_Group.startGroup(&fbb)
    schema_Group.add(id: id, &fbb)
    schema_Group.add(description: description, &fbb)
    schema_Group.addVectorOf(definitions: definitions, &fbb)
    return schema_Group.endGroup(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.description.p, fieldName: "description", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.definitions.p, fieldName: "definitions", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

public struct schema_Usage: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsUsage(bb: ByteBuffer) -> schema_Usage { return schema_Usage(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case pos = 4
    case definitions = 6
    case groups = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var pos: schema_POS { let o = _accessor.offset(VTOFFSET.pos.v); return o == 0 ? .v : schema_POS(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .v }
  public var definitionsCount: Int32 { let o = _accessor.offset(VTOFFSET.definitions.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func definitions(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.definitions.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var groupsCount: Int32 { let o = _accessor.offset(VTOFFSET.groups.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func groups(at index: Int32) -> schema_Group? { let o = _accessor.offset(VTOFFSET.groups.v); return o == 0 ? nil : schema_Group(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startUsage(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(pos: schema_POS, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pos.rawValue, def: 0, at: VTOFFSET.pos.p) }
  public static func addVectorOf(definitions: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: definitions, at: VTOFFSET.definitions.p) }
  public static func addVectorOf(groups: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: groups, at: VTOFFSET.groups.p) }
  public static func endUsage(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUsage(
    _ fbb: inout FlatBufferBuilder,
    pos: schema_POS = .v,
    definitionsVectorOffset definitions: Offset = Offset(),
    groupsVectorOffset groups: Offset = Offset()
  ) -> Offset {
    let __start = schema_Usage.startUsage(&fbb)
    schema_Usage.add(pos: pos, &fbb)
    schema_Usage.addVectorOf(definitions: definitions, &fbb)
    schema_Usage.addVectorOf(groups: groups, &fbb)
    return schema_Usage.endUsage(&fbb, start: __start)
  }
  public static func sortVectorOfUsage(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: schema_POS, fbb: ByteBuffer) -> schema_Usage? {
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = fbb.read(def: schema_POS.self, position: Int(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb)))
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return schema_Usage(fbb, o: tableOffset)
      }
    }
    return nil
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.pos.p, fieldName: "pos", required: false, type: schema_POS.self)
    try _v.visit(field: VTOFFSET.definitions.p, fieldName: "definitions", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.groups.p, fieldName: "groups", required: false, type: ForwardOffset<Vector<ForwardOffset<schema_Group>, schema_Group>>.self)
    _v.finish()
  }
}

public struct schema_Entry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsEntry(bb: ByteBuffer) -> schema_Entry { return schema_Entry(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case term = 6
    case etymologies = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: String! { let o = _accessor.offset(VTOFFSET.key.v); return _accessor.string(at: o) }
  public var keySegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.key.v) }
  public var term: String? { let o = _accessor.offset(VTOFFSET.term.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var termSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.term.v) }
  public var etymologiesCount: Int32 { let o = _accessor.offset(VTOFFSET.etymologies.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func etymologies(at index: Int32) -> schema_Etymology? { let o = _accessor.offset(VTOFFSET.etymologies.v); return o == 0 ? nil : schema_Etymology(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(key: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: key, at: VTOFFSET.key.p) }
  public static func add(term: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: term, at: VTOFFSET.term.p) }
  public static func addVectorOf(etymologies: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: etymologies, at: VTOFFSET.etymologies.p) }
  public static func endEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createEntry(
    _ fbb: inout FlatBufferBuilder,
    keyOffset key: Offset = Offset(),
    termOffset term: Offset = Offset(),
    etymologiesVectorOffset etymologies: Offset = Offset()
  ) -> Offset {
    let __start = schema_Entry.startEntry(&fbb)
    schema_Entry.add(key: key, &fbb)
    schema_Entry.add(term: term, &fbb)
    schema_Entry.addVectorOf(etymologies: etymologies, &fbb)
    return schema_Entry.endEntry(&fbb, start: __start)
  }
  public static func sortVectorOfEntry(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> schema_Entry? {
    let key = key.utf8.map { $0 }
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb), key, fbb: fbb)
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return schema_Entry(fbb, o: tableOffset)
      }
    }
    return nil
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.key.p, fieldName: "key", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.term.p, fieldName: "term", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.etymologies.p, fieldName: "etymologies", required: false, type: ForwardOffset<Vector<ForwardOffset<schema_Etymology>, schema_Etymology>>.self)
    _v.finish()
  }
}

public struct schema_Dictionary: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsDictionary(bb: ByteBuffer) -> schema_Dictionary { return schema_Dictionary(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case name = 6
    case entries = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var entriesCount: Int32 { let o = _accessor.offset(VTOFFSET.entries.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func entries(at index: Int32) -> schema_Entry? { let o = _accessor.offset(VTOFFSET.entries.v); return o == 0 ? nil : schema_Entry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func entriesBy(key: String) -> schema_Entry? { let o = _accessor.offset(VTOFFSET.entries.v); return o == 0 ? nil : schema_Entry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public static func startDictionary(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func addVectorOf(entries: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: entries, at: VTOFFSET.entries.p) }
  public static func endDictionary(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDictionary(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    entriesVectorOffset entries: Offset = Offset()
  ) -> Offset {
    let __start = schema_Dictionary.startDictionary(&fbb)
    schema_Dictionary.add(id: id, &fbb)
    schema_Dictionary.add(name: name, &fbb)
    schema_Dictionary.addVectorOf(entries: entries, &fbb)
    return schema_Dictionary.endDictionary(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.entries.p, fieldName: "entries", required: false, type: ForwardOffset<Vector<ForwardOffset<schema_Entry>, schema_Entry>>.self)
    _v.finish()
  }
}

