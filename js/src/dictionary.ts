import { writeFile } from "node:fs/promises";

import { startService } from "./service.js";
import { withTemporaryFile } from "./tmp.js";
import type {
  DictionaryOptions,
  Entry,
  LookupOptions,
  Query,
  SearchOptions,
} from "./types.js";
import { generateOutputPath, queryToString } from "./utils.js";

class Dictionary {
  private readonly options: DictionaryOptions;

  constructor(
    private readonly path: string,
    options: Partial<DictionaryOptions> = {}
  ) {
    this.options = options;
  }

  /**
   * Compiles an ODXML file to a compiled dictionary
   *
   * @param xmlPath The path to the XML file to compile
   * @param outPath The destination path (autogenerated if omitted)
   * @returns A pointer to the compiled Dictionary
   */
  static async compile(xmlPath: string, outPath?: string): Promise<Dictionary> {
    const commands = ["compile"];
    const out = outPath ?? generateOutputPath(xmlPath);

    commands.push(xmlPath);

    await startService().run({
      function: "compile",
      parameters: {
        outPath: out,
        path: xmlPath,
      },
    });

    return new Dictionary(out);
  }

  /**
   * Writes an ODXML string to a compiled dictionary file
   *
   * @param xml The XML to compile
   * @param outPath The destination path
   * @returns A pointer to the compiled dictionary
   */
  static async write(xml: string, outPath: string): Promise<Dictionary> {
    return withTemporaryFile(async (tmp) => {
      await writeFile(tmp, xml, "utf-8");

      await startService().run({
        function: "compile",
        parameters: {
          outPath: outPath,
          path: tmp,
        },
      });

      return new Dictionary(outPath);
    });
  }

  /**
   * Indexes a compiled dictionary so it can be searched via the search() method
   */
  async index() {
    await startService(this.path).run({ function: "index", parameters: {} });
  }

  /**
   * Searches a compiled dictionary using full-text search
   *
   * @param query The query (or a list of queries) to search
   * @param options Search options
   * @returns A nested array of entries
   */
  async search(
    query: Query | Query[],
    options: SearchOptions = {}
  ): Promise<Entry[][]> {
    const queries = Array.isArray(query) ? query : [query];

    return Promise.all(
      queries.map(queryToString).map(async (query) => {
        return JSON.parse(
          await startService(this.path).run({
            function: "search",
            parameters: {
              query,
              exact: options.exact ?? "false",
              force: options.force ?? "false",
            },
          })
        ) as Entry[];
      })
    );
  }

  /**
   * Returns a list of all headwords in the dictionary
   *
   * @returns A list of all headwords in the dictionary
   */
  async lexicon(): Promise<string[]> {
    const lexicon = await startService(this.path).run({
      function: "lexicon",
      parameters: {},
    });
    return lexicon.toString().trim().split("\n");
  }

  /**
   * Looks up an entry in the dictionary
   *
   * @param query The query (or a list of queries) to lookup
   * @param options Lookup options
   * @returns A nested array of entries
   */
  async lookup(
    query: Query | Query[],
    options: LookupOptions = {}
  ): Promise<Entry[][]> {
    const queries = Array.isArray(query) ? query : [query];

    const { follow, split = this.options.defaultSplitThreshold } = options;

    return startService(this.path)
      .run({
        function: "lookup",
        parameters: {
          follow: follow?.toString() ?? "false",
          split: split?.toString() ?? "0",
          queries: queries.map(queryToString).join("|"),
        },
      })
      .then(JSON.parse);
  }

  /**
   * Splits a query into its definable subparts
   *
   * @param query The query (or a list of queries) to lookup
   * @param options Lookup options
   * @returns A nested array of entries
   */
  async split(query: string, threshold: number): Promise<Entry[]> {
    const result = await startService(this.path).run({
      function: "split",
      parameters: {
        threshold: threshold.toString(),
        query,
      },
    });
    return JSON.parse(result);
  }
}

export { Dictionary };
