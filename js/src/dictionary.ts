import { writeFile } from "node:fs/promises";
import { basename, dirname, extname, join } from "node:path";

import { exec } from "./exec";
import { withTemporaryFile } from "./tmp";
import type {
  DictionaryOptions,
  Entry,
  LookupOptions,
  Query,
  SearchOptions,
  SplitOptions,
} from "./types";
import { generateOutputPath, queryToString } from "./utils";

class Dictionary {
  private readonly options: DictionaryOptions;

  constructor(readonly path: string, options: Partial<DictionaryOptions> = {}) {
    this.options = {
      defaultSplitThreshold: 2,
      ...options,
    };
  }

  /**
   * Compiles an ODXML file to a compiled dictionary
   *
   * @param xmlPath The path to the XML file to compile
   * @param outPath The destination path (autogenerated if omitted)
   * @returns A pointer to the compiled Dictionary
   */
  static async compile(xmlPath: string, outPath?: string): Promise<Dictionary> {
    const commands = ["compile"];
    const out = outPath ?? generateOutputPath(xmlPath);

    if (outPath) {
      commands.push("-o");
      commands.push(outPath ?? out);
    }

    commands.push(xmlPath);

    await exec(...commands);

    return new Dictionary(out);
  }

  /**
   * Writes an ODXML string to a compiled dictionary file
   *
   * @param xml The XML to compile
   * @param outPath The destination path
   * @returns A pointer to the compiled dictionary
   */
  static async write(xml: string, outPath: string): Promise<Dictionary> {
    return withTemporaryFile(async (tmp) => {
      await writeFile(tmp, xml, "utf-8");
      await exec("compile", "-o", outPath, tmp);
      return new Dictionary(outPath);
    });
  }

  /**
   * Indexes a compiled dictionary so it can be searched via the search() method
   */
  async index() {
    await exec("index", this.path);
  }

  /**
   * Searches a compiled dictionary using full-text search
   *
   * @param query The query (or a list of queries) to search
   * @param options Search options
   * @returns A nested array of entries
   */
  async search(
    query: Query | Query[],
    options: SearchOptions = {}
  ): Promise<Entry[][]> {
    const queries = Array.isArray(query) ? query : [query];

    return Promise.all(
      queries.map(queryToString).map(async (query) => {
        const commands = ["search"];

        if (options.force) {
          commands.push("-i");
        }

        commands.push(this.path);
        commands.push(query);

        const raw = await exec(...commands);

        return JSON.parse(raw);
      })
    );
  }

  /**
   * Looks up an entry in the dictionary
   *
   * @param query The query (or a list of queries) to lookup
   * @param options Lookup options
   * @returns A nested array of entries
   */
  async lookup(
    query: Query | Query[],
    options: LookupOptions = {}
  ): Promise<Entry[][]> {
    const queries = Array.isArray(query) ? query : [query];

    const { split = this.options.defaultSplitThreshold } = options;

    return Promise.all(
      queries.map(queryToString).map(async (query) => {
        const raw = await exec(
          "lookup",
          "-s",
          split.toString(),
          this.path,
          query
        );

        return JSON.parse(raw);
      })
    );
  }

  /**
   * Splits a query into its definable subparts
   *
   * @param query The query (or a list of queries) to lookup
   * @param options Lookup options
   * @returns A nested array of entries
   */
  async split(query: string, options: SplitOptions = {}): Promise<Entry[]> {
    const queries = Array.isArray(query) ? query : [query];

    const { threshold = this.options.defaultSplitThreshold } = options;

    const result = await exec(
      "split",
      "-t",
      threshold.toString(),
      this.path,
      query
    );

    return JSON.parse(result);
  }
}

export { Dictionary };
