import { writeFile } from "node:fs/promises";

import { startService, stopService } from "./service.js";
import { withTemporaryFile } from "./tmp.js";
import type {
  DictionaryOptions,
  Entry,
  LookupOptions,
  Query,
  SearchOptions,
} from "./types.js";
import { generateOutputPath, queryToString } from "./utils.js";

class Dictionary {
  private readonly options: DictionaryOptions;

  constructor(readonly path: string, options: Partial<DictionaryOptions> = {}) {
    this.options = options;
  }

  destroy() {
    stopService();
  }

  /**
   * Compiles an ODXML file to a compiled dictionary
   *
   * @param xmlPath The path to the XML file to compile
   * @param outPath The destination path (autogenerated if omitted)
   * @returns A pointer to the compiled Dictionary
   */
  static async compile(xmlPath: string, outPath?: string): Promise<Dictionary> {
    const commands = ["compile"];
    const out = outPath ?? generateOutputPath(xmlPath);

    if (outPath) {
      commands.push("-o");
      commands.push(outPath ?? out);
    }

    commands.push(xmlPath);

    await startService().run(commands);

    return new Dictionary(out);
  }

  /**
   * Writes an ODXML string to a compiled dictionary file
   *
   * @param xml The XML to compile
   * @param outPath The destination path
   * @returns A pointer to the compiled dictionary
   */
  static async write(xml: string, outPath: string): Promise<Dictionary> {
    return withTemporaryFile(async (tmp) => {
      await writeFile(tmp, xml, "utf-8");
      await startService().run(["compile", "-o", outPath, tmp]);
      return new Dictionary(outPath);
    });
  }

  /**
   * Indexes a compiled dictionary so it can be searched via the search() method
   */
  async index() {
    await startService().run(["index", this.path]);
  }

  /**
   * Searches a compiled dictionary using full-text search
   *
   * @param query The query (or a list of queries) to search
   * @param options Search options
   * @returns A nested array of entries
   */
  async search(
    query: Query | Query[],
    options: SearchOptions = {}
  ): Promise<Entry[][]> {
    const queries = Array.isArray(query) ? query : [query];

    return Promise.all(
      queries.map(queryToString).map(async (query) => {
        const commands = ["search"];

        if (options.force) {
          commands.push("-i");
        }

        commands.push(this.path);
        commands.push(query);

        return JSON.parse(await startService().run(commands)) as Entry[];
      })
    );
  }

  /**
   * Returns a list of all headwords in the dictionary
   *
   * @returns A list of all headwords in the dictionary
   */
  async lexicon(): Promise<string[]> {
    return (await startService().run(["lexicon", this.path]))
      .trim()
      .split("\n");
  }

  /**
   * Looks up an entry in the dictionary
   *
   * @param query The query (or a list of queries) to lookup
   * @param options Lookup options
   * @returns A nested array of entries
   */
  async lookup(
    query: Query | Query[],
    options: LookupOptions = {}
  ): Promise<Entry[][]> {
    const queries = Array.isArray(query) ? query : [query];

    const { follow, split = this.options.defaultSplitThreshold } = options;

    return startService()
      .run([
        "lookup",
        "-f",
        "json",
        follow ? "--follow" : "",
        ...(split ? ["-s", split.toString()] : []),
        this.path,
        ...queries.map(queryToString),
      ])
      .then(JSON.parse);
  }

  /**
   * Splits a query into its definable subparts
   *
   * @param query The query (or a list of queries) to lookup
   * @param options Lookup options
   * @returns A nested array of entries
   */
  async split(query: string, threshold: number): Promise<Entry[]> {
    const result = await startService().run([
      "split",
      ...(threshold ? ["-t", threshold.toString()] : []),
      this.path,
      query,
    ]);

    return JSON.parse(result);
  }
}

export { Dictionary };
